<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL | David Liman</title>
<meta name=keywords content><meta name=description content="This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL

For the context,Spring Framework 5 introduced the so-called Reactive Stack. The keyword reactive refers to the Reactive Manifesto, which is a specification for asynchronous stream processing with non-blocking back-pressure.
This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc."><meta name=author content="David Liman"><link rel=canonical href=https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel=stylesheet><link rel=icon href=https://dvliman.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvliman.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvliman.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dvliman.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dvliman.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/"><meta property="og:site_name" content="David Liman"><meta property="og:title" content="Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL"><meta property="og:description" content="This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL
For the context,Spring Framework 5 introduced the so-called Reactive Stack. The keyword reactive refers to the Reactive Manifesto, which is a specification for asynchronous stream processing with non-blocking back-pressure. This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-03-24T09:00:00+00:00"><meta property="article:modified_time" content="2019-03-24T09:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL"><meta name=twitter:description content="This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL

For the context,Spring Framework 5 introduced the so-called Reactive Stack. The keyword reactive refers to the Reactive Manifesto, which is a specification for asynchronous stream processing with non-blocking back-pressure.
This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvliman.github.io/post/"},{"@type":"ListItem","position":2,"name":"Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL","item":"https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL","name":"Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL","description":"This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL\nFor the context,Spring Framework 5 introduced the so-called Reactive Stack. The keyword reactive refers to the Reactive Manifesto, which is a specification for asynchronous stream processing with non-blocking back-pressure. This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc.\n","keywords":[],"articleBody":"This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL\nFor the context,Spring Framework 5 introduced the so-called Reactive Stack. The keyword reactive refers to the Reactive Manifesto, which is a specification for asynchronous stream processing with non-blocking back-pressure. This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc.\nIn short, Spring Webflux is a non-blocking web framework that uses Reactor library, which implements the Reactive Streams Specifications, to asynchronously manage HTTP requests.\nRequirements Say we want to build an HTTP service that can do the following:\ncurl -XPOST /api/users/create -d '{\"name\": \"some-name\", \"email\": \"some-email\"}' curl -XPOST /api/users/fetch -d '{\"userid\": 123}' curl -XPOST /api/users/all Note: the final code repo is here\nLet’s start the journey by going to Spring Initializr. It is a very handy tool to generate the skeleton project.\nProject: Gradle Project Language: Kotlin Spring Boot: 2.2.0 (SNAPSHOT) Group: com.dvliman Artifact: demo Dependencies: Reactive Web Generate Project — ⌘ + ⏎ At this point, if you run ./gradlew bootRun, you should see something like this: Good! Now we just need to add additional dependencies: Note: At the time of writing, there is no “official” reactive JDBC drivers. JDBC is inherently a blocking API. However, there are some third-party libraries that we can use. I picked David Moten’s rxjava2-jdbc library because it has a great documentation and it implements the Reactive Streams specifications\nDesign Before we jump into coding, let’s think about what we need to build. At the minimum, we will need to:\nread a configuration file such as database connection string be able to read and write some data into our database process HTTP requests Coding It is a good idea to start thinking about the data. So let’s define the schema And write some queries to get a feel for how it works and what not Next, let’s write a code to read the config file: The @Value annotation takes a SPEL-expression to evaluate config values in the application.properties which contains the database connection string Okay, now we can add a @Configuration for all our beans With database connection bean setup, we can start wiring up the model and repository. So let’s work on that: Notice how the return type signature is Mono or Flux? They are both implementations of Reactive Streams Publisher interface. I am not going to go into too much details about Reactive Streams but in essence:\nMono is a stream of 0..1 elements Flux is a stream of 0..N elements a Publisher is responsible for publishing elements of type T and provides a subscribe method for subscribers to connect to it a Subscriber connects to a Publisher, receives a confirmation via onSubscribe, then receive data via the onNext callbacks and additional signals via onError and onComplete a Subscription represents a link between a Publisher and a Subscriber, and allows for backpressuring the publisher with request or terminating the link with cancel a Processor combines the capabilities of a Publisher and a Subscriberin a single interface The next class to take a look is the class that handles the HTTP requests In Spring Webflux, HTTP handler is essentially a function that takes HTTP request and return HTTP response. (ServerRequest) -\u003e Mono\nFinally, let’s add a router that routes incoming HTTP requests to the HTTP handler based on URL, HTTP method, and Content-Type header That is it! Now you can test with curl:\n","wordCount":"585","inLanguage":"en","datePublished":"2019-03-24T09:00:00Z","dateModified":"2019-03-24T09:00:00Z","author":{"@type":"Person","name":"David Liman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/"},"publisher":{"@type":"Organization","name":"David Liman","logo":{"@type":"ImageObject","url":"https://dvliman.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvliman.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://dvliman.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvliman.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvliman.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvliman.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL</h1><div class=post-meta><span title='2019-03-24 09:00:00 +0000 UTC'>March 24, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;585 words&nbsp;·&nbsp;David Liman&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring-webflux-kotlin-postgresql.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>This post shows how to create a reactive web service with Spring Webflux, Kotlin, PostgreSQL</p><blockquote><p>For the context,<a href=https://spring.io/>Spring Framework 5</a> introduced the so-called <strong>Reactive Stack</strong>. The keyword <code>reactive</code> refers to the <a href=https://www.reactivemanifesto.org/>Reactive Manifesto</a>, which is a <a href=https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md>specification</a> for asynchronous stream processing with non-blocking back-pressure.
This specification is a joint collaboration between engineers from Netflix, Pivotal, Red Hat, Twitter and many others. It has been implemented in many languages such as: Java, Javascript, Swift, NET, etc.</p></blockquote><blockquote><p>In short, Spring Webflux is a non-blocking web framework that uses <a href=https://projectreactor.io/>Reactor</a> library, which implements the Reactive Streams Specifications, to asynchronously manage HTTP requests.</p></blockquote><h1 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h1><p>Say we want to build an HTTP service that can do the following:</p><ul><li><code>curl -XPOST /api/users/create -d '{"name": "some-name", "email": "some-email"}'</code></li><li><code>curl -XPOST /api/users/fetch -d '{"userid": 123}'</code></li><li><code>curl -XPOST /api/users/all</code></li></ul><p>Note: the final code repo is <a href=https://github.com/dvliman/spring-webflux-kotlin-postgresql/>here</a></p><p>Let’s start the journey by going to <a href=https://start.spring.io/>Spring Initializr</a>. It is a very handy tool to generate the skeleton project.</p><ul><li><strong>Project:</strong> Gradle Project</li><li><strong>Language:</strong> Kotlin</li><li><strong>Spring Boot:</strong> 2.2.0 (SNAPSHOT)</li><li><strong>Group:</strong> com.dvliman</li><li><strong>Artifact:</strong> demo</li><li><strong>Dependencies:</strong> Reactive Web</li><li><strong>Generate Project — ⌘ + ⏎</strong></li></ul><p>At this point, if you run <code>./gradlew bootRun</code>, you should see something like this:
<script src=https://gist.github.com/dvliman/118a912acf0c61016e1d8ca7b79d865e.js></script></p><p>Good! Now we just need to add additional dependencies:
<script src=https://gist.github.com/dvliman/af1f260b9a7236bb67d3cb458923165f.js></script></p><p>Note: At the time of writing, there is no “official” reactive JDBC drivers. JDBC is inherently a blocking API. However, there are some third-party libraries that we can use. I picked David Moten’s rxjava2-jdbc library because it has a great <a href=https://github.com/davidmoten/rxjava2-jdbc/blob/master/README.adoc>documentation</a> and it implements the Reactive Streams specifications</p><h1 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h1><p>Before we jump into coding, let’s think about what we need to build. At the minimum, we will need to:</p><ul><li>read a configuration file such as database connection string</li><li>be able to read and write some data into our database</li><li>process HTTP requests</li></ul><h1 id=coding>Coding<a hidden class=anchor aria-hidden=true href=#coding>#</a></h1><p>It is a good idea to start thinking about the data. So let’s define the schema
<script src=https://gist.github.com/dvliman/a23b16a492eee4bf75a84f4f95bb1aea.js></script></p><p>And write some queries to get a feel for how it works and what not
<script src=https://gist.github.com/dvliman/ee7a6c929ba6183fa3edc01adb0ce03d.js></script></p><p>Next, let’s write a code to read the config file:
<script src=https://gist.github.com/dvliman/12646919ee99201aa542c5a47228b8dd.js></script></p><p>The <code>@Value</code> annotation takes a SPEL-expression to evaluate config values in the <code>application.properties</code> which contains the database connection string
<script src=https://gist.github.com/dvliman/fededaad0b1edc4d26030c190473c68c.js></script></p><p>Okay, now we can add a <code>@Configuration</code> for all our <code>beans</code>
<script src=https://gist.github.com/dvliman/cb4b250151757fcf8abd69fecf847e5a.js></script></p><p>With database connection bean setup, we can start wiring up the model and repository. So let’s work on that:
<script src=https://gist.github.com/dvliman/007f400e82f28ab65d2696fd473e118f.js></script><script src=https://gist.github.com/dvliman/1e4a4d5d9a36e64a63727ba4636fbd8a.js></script></p><p>Notice how the return type signature is <code>Mono&lt;User></code> or <code>Flux&lt;User></code>? They are both implementations of Reactive Streams <a href=http://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/org/reactivestreams/Publisher.html>Publisher</a> interface. I am not going to go into too much details about Reactive Streams but in essence:</p><ul><li>Mono is a stream of 0..1 elements</li><li>Flux is a stream of 0..N elements</li><li>a <code>Publisher&lt;T></code> is responsible for publishing elements of type <code>T</code> and provides a <code>subscribe</code> method for subscribers to connect to it</li><li>a <code>Subscriber&lt;T></code> connects to a <code>Publisher</code>, receives a confirmation via <code>onSubscribe</code>, then receive data via the <code>onNext</code> callbacks and additional signals via <code>onError</code> and <code>onComplete</code></li><li>a <code>Subscription</code> represents a link between a <code>Publisher</code> and a <code>Subscriber</code>, and allows for backpressuring the publisher with <code>request</code> or terminating the link with <code>cancel</code></li><li>a <code>Processor</code> combines the capabilities of a <code>Publisher</code> and a <code>Subscriber</code>in a single interface</li></ul><p>The next class to take a look is the class that handles the HTTP requests
<script src=https://gist.github.com/dvliman/db12cf21d3289e1eb12946d5c6730cc3.js></script></p><p>In Spring Webflux, HTTP handler is essentially a function that takes HTTP request and return HTTP response. <code>(ServerRequest) -> Mono&lt;ServerResponse></code></p><p>Finally, let’s add a router that routes incoming HTTP requests to the HTTP handler based on URL, HTTP method, and Content-Type header
<script src=https://gist.github.com/dvliman/55861ba7e557704ab31d2a1ddd6a3198.js></script></p><p>That is it! Now you can test with curl:</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://dvliman.github.io/post/livestreaming-clojure/><span class=title>« Prev</span><br><span>Building a Live Streaming app in Clojure</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>