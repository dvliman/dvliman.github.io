<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My handy Clojure debugging tools | David Liman</title>
<meta name=keywords content><meta name=description content="In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let&rsquo;s start with each tool
(println …)
It is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact
(defn x [x] (println x) x)"><meta name=author content="David Liman"><link rel=canonical href=https://dvliman.github.io/post/my-handy-clojure-debugging-tools/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel=stylesheet><link rel=icon href=https://dvliman.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvliman.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvliman.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dvliman.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dvliman.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dvliman.github.io/post/my-handy-clojure-debugging-tools/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dvliman.github.io/post/my-handy-clojure-debugging-tools/"><meta property="og:site_name" content="David Liman"><meta property="og:title" content="My handy Clojure debugging tools"><meta property="og:description" content="In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let’s start with each tool
(println …)
It is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact
(defn x [x] (println x) x)"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-26T06:00:00+00:00"><meta property="article:modified_time" content="2024-08-26T06:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="My handy Clojure debugging tools"><meta name=twitter:description content="In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let&rsquo;s start with each tool
(println …)
It is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact
(defn x [x] (println x) x)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvliman.github.io/post/"},{"@type":"ListItem","position":2,"name":"My handy Clojure debugging tools","item":"https://dvliman.github.io/post/my-handy-clojure-debugging-tools/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My handy Clojure debugging tools","name":"My handy Clojure debugging tools","description":"In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let\u0026rsquo;s start with each tool\n(println …)\nIt is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact\n(defn x [x] (println x) x)\n","keywords":[],"articleBody":"In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let’s start with each tool\n(println …)\nIt is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact\n(defn x [x] (println x) x)\nIn the next version, I almost always wrap println in a function in the same namespace, slurp, and raise the forms. This helps speed up typing a little bit. We still have to undo changes\n(def state (atom nil))\n(defn x [x] (reset! state x))\nVery useful to capture any data that goes beyond primitive values. Deref the state. Now you can manipulate the data.\nIDE debuggers\nI have my fair share of trying out different debugger tools: cider debugger, enlighten, cursive debuggers, etc. They are handy for tracing codebases. They automatically follow the callstacks, often leading you to code branches that you did not expect.\nBut in practice, I don’t use them as much - mainly because I feel like they can be a bit distracting due to how we generally instrument the breakpoints, hitting next/up/down the call stack, inspecting values, etc.\nThey are definitely useful as a starting point in big and unfamiliar codebases\nClojure libraries such as spyscope, hashp, scope-capture, FlowStorm, etc\nThere are plenty of excellent functions and macros that help with debugging. Some printout recursive calls nicely. I tend to fall back to something simple like a hashp. It gets the job done nicely. Saves some typing\nThen one day, when I was pairing with my colleague Craig Ludington; he used a combination of println, atom, and reader macro - all at once; which I thought was pretty cool. I ended up modifying and extending his debug code but I want to give credit back to him - Thank you, Craig!\nLet’s say we have this (hypothetical) code: And the ask is to modify such that if the loan-amount input was 10000.50, the output should be :modest, not :small\nWe can add a reader tag that looks like this Then run the code (calculate-loan-size 10000.50)\nWe can call (user/tags) to print out the debug tags. On emacs, I set the shortcut command+6 and command+5 to clear out the tags 0, 1, 2, and 3 corresponds to 4 forms that are being the debugged 1 and :same-values indicates there we only 1 call and all of them have the same values. It is useful to know when we have multiple calls (intentional or not) and if the values are the same (between 1 loan-amount 10000) is self explanatory false is the return value We can pull the value out with the index (user/logs 0) or with form (user/logs '(between 1 loan-amount 10000))\nuser/logs takes variadic function. For example, if we capture an HTTP request map, we can do (user/logs 0 last :header #(get % \"Content-Type\"))\nThis is how it is implemented in my ~/.clojure/user.clj And ~/.clojure/data_readers.clj I can load this code in any project i.e in the deps.edn On emacs, I have set the keybindings to: and the definitions: With combinations of keyboard shortcuts, emacs buffers, and REPL, this makes debugging a lot faster (for me)\nI hope this is useful for someone. I would love hear your thoughts on how you debug your clojure code!\n","wordCount":"574","inLanguage":"en","datePublished":"2024-08-26T06:00:00Z","dateModified":"2024-08-26T06:00:00Z","author":{"@type":"Person","name":"David Liman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvliman.github.io/post/my-handy-clojure-debugging-tools/"},"publisher":{"@type":"Organization","name":"David Liman","logo":{"@type":"ImageObject","url":"https://dvliman.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvliman.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://dvliman.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvliman.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvliman.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvliman.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">My handy Clojure debugging tools</h1><div class=post-meta><span title='2024-08-26 06:00:00 +0000 UTC'>August 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;David Liman&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/my-handy-clojure-debugging-tools.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In this blog post, I’d like to share how my debugging tools for Clojure have evolved over the past years. Let&rsquo;s start with each tool</p><p><strong><code>(println …)</code></strong></p><p>It is the most versatile technique. There is no learning curve. Focus on tapping at the right places, make the assertions, and move on. The only downside would be there is quite a lot of typing and undo-ing after the fact</p><p><strong><code>(defn x [x] (println x) x)</code></strong></p><p>In the next version, I almost always wrap println in a function in the same namespace, slurp, and raise the forms. This helps speed up typing a little bit. We still have to undo changes</p><p><strong><code>(def state (atom nil))</code></strong><br><strong><code>(defn x [x] (reset! state x))</code></strong></p><p>Very useful to capture any data that goes beyond primitive values. Deref the state. Now you can manipulate the data.</p><p><strong>IDE debuggers</strong></p><p>I have my fair share of trying out different debugger tools: cider debugger, enlighten, cursive debuggers, etc. They are handy for tracing codebases. They automatically follow the callstacks, often leading you to code branches that you did not expect.</p><p>But in practice, I don&rsquo;t use them as much - mainly because I feel like they can be a bit distracting due to how we generally instrument the breakpoints, hitting next/up/down the call stack, inspecting values, etc.</p><p>They are definitely useful as a starting point in big and unfamiliar codebases</p><p><strong>Clojure libraries such as <a href=https://github.com/dgrnbrg/spyscope>spyscope</a>, <a href=https://github.com/weavejester/hashp>hashp</a>, <a href=https://github.com/vvvvalvalval/scope-capture>scope-capture</a>, <a href=http://www.flow-storm.org/>FlowStorm</a>, etc</strong></p><p>There are plenty of excellent functions and macros that help with debugging. Some printout recursive calls nicely. I tend to fall back to something simple like a hashp. It gets the job done nicely. Saves some typing</p><p>Then one day, when I was pairing with my colleague Craig Ludington; he used a combination of println, atom, and reader macro - all at once; which I thought was pretty cool. I ended up modifying and extending his debug code but I want to give credit back to him - Thank you, Craig!</p><p>Let&rsquo;s say we have this (hypothetical) code:
<script src=https://gist.github.com/dvliman/d01208f7c48b40c44db89905b14bf0cd.js></script></p><p>And the ask is to modify such that if the <code>loan-amount</code> input was 10000.50, the output should be <code>:modest</code>, not <code>:small</code></p><p>We can add a reader tag that looks like this
<script src=https://gist.github.com/dvliman/d3e015fb667253c543af3b2318acd8b0.js></script></p><p>Then run the code <code>(calculate-loan-size 10000.50)</code></p><p>We can call <code>(user/tags)</code> to print out the debug tags. On emacs, I set the shortcut command+6 and command+5 to clear out the tags
<script src=https://gist.github.com/dvliman/c387742ef299e175c13dc294893bb104.js></script></p><ol><li>0, 1, 2, and 3 corresponds to 4 forms that are being the debugged</li><li>1 and <code>:same-values</code> indicates there we only 1 call and all of them have the same values. It is useful to know when we have multiple calls (intentional or not) and if the values are the same</li><li><code>(between 1 loan-amount 10000)</code> is self explanatory</li><li><code>false</code> is the return value</li></ol><p>We can pull the value out with the index <code>(user/logs 0)</code> or with form <code>(user/logs '(between 1 loan-amount 10000))</code></p><p><a href=https://github.com/dvliman/.clojure/blob/cb2153279931f3537140d8a84335a73fbf989147/user.clj#L11>user/logs</a> takes variadic function. For example, if we capture an HTTP request map, we can do <code>(user/logs 0 last :header #(get % "Content-Type"))</code></p><p>This is how it is implemented in my <code>~/.clojure/user.clj</code>
<script src=https://gist.github.com/dvliman/9ae80ebbba797fde22e0f1915ce9f93c.js></script></p><p>And <code>~/.clojure/data_readers.clj</code>
<script src=https://gist.github.com/dvliman/c70d3e88b88d3d623e2eec2d7fce68b6.js></script></p><p>I can load this code in any project i.e in the <code>deps.edn</code>
<script src=https://gist.github.com/dvliman/9172a211270c38c0104d32e0579429f1.js></script></p><p>On emacs, I have set the keybindings to:
<script src=https://gist.github.com/dvliman/65ee959b2d498075bdf5e5d3075b5e8b.js></script></p><p>and the definitions:
<script src=https://gist.github.com/dvliman/93c1df9f053565de880392d966ee0572.js></script></p><p>With combinations of keyboard shortcuts, emacs buffers, and REPL, this makes debugging a lot faster (for me)</p><p>I hope this is useful for someone. I would love hear your thoughts on how you debug your clojure code!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://dvliman.github.io/post/dont-use-clj-time-use-clojurejava-time-instead/><span class=title>Next »</span><br><span>Don't use clj-time, use clojure.java-time instead</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>