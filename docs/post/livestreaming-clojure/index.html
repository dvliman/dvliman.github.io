<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Live Streaming app in Clojure | David Liman</title>
<meta name=keywords content><meta name=description content="I want to echo John Carmack’s tweet that all giant companies use open-source FFmpeg in the backends. FFmpeg is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.
It looks like this:

     



     


Users can:

watch live-streaming content, or
playback on-demand videos from our content library

High level
Behind the scene, we have:"><meta name=author content="David Liman"><link rel=canonical href=https://dvliman.github.io/post/livestreaming-clojure/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://dvliman.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvliman.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvliman.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dvliman.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dvliman.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dvliman.github.io/post/livestreaming-clojure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dvliman.github.io/post/livestreaming-clojure/"><meta property="og:site_name" content="David Liman"><meta property="og:title" content="Building a Live Streaming app in Clojure"><meta property="og:description" content="I want to echo John Carmack’s tweet that all giant companies use open-source FFmpeg in the backends. FFmpeg is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.
It looks like this: Users can: watch live-streaming content, or playback on-demand videos from our content library High level Behind the scene, we have:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-28T06:00:00+00:00"><meta property="article:modified_time" content="2022-02-28T06:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Live Streaming app in Clojure"><meta name=twitter:description content="I want to echo John Carmack’s tweet that all giant companies use open-source FFmpeg in the backends. FFmpeg is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.
It looks like this:

     



     


Users can:

watch live-streaming content, or
playback on-demand videos from our content library

High level
Behind the scene, we have:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvliman.github.io/post/"},{"@type":"ListItem","position":2,"name":"Building a Live Streaming app in Clojure","item":"https://dvliman.github.io/post/livestreaming-clojure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Live Streaming app in Clojure","name":"Building a Live Streaming app in Clojure","description":"I want to echo John Carmack’s tweet that all giant companies use open-source FFmpeg in the backends. FFmpeg is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.\nIt looks like this: Users can: watch live-streaming content, or playback on-demand videos from our content library High level Behind the scene, we have:\n","keywords":[],"articleBody":"I want to echo John Carmack’s tweet that all giant companies use open-source FFmpeg in the backends. FFmpeg is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.\nIt looks like this: Users can: watch live-streaming content, or playback on-demand videos from our content library High level Behind the scene, we have:\nIP cameras are wired up in each studio room. The cameras support the RTSP protocol. A software pipeline integrated with our custom CMS to broadcast (stream) our cameras feed to the internet while simultaneously recording and storing the content to AWS S3 storage for on-demand playback. How it all works together: We configure classes (the recordings) to start at a particular time in our dashboard. The time aligns with our studio schedules, where gym members would often join our classes to work out alongside the instructors.\nWe kick off a dedicated ec2 instance with FFmpeg baked in an AMI image when the class starts. We call this our encoder/transcoder. As soon as the ec2 boots up, it runs the cloud-init script, which starts the Clojure process and mount (a state management library) that would then starts the dependencies: This would in turn calls start-stream: The start-stream logic is actually pretty simple. It pulls feed from our camera and egress out our CDN partner The output would be a playback URL that our video player would be pulling from.\nNotice we are essentially invoking the FFmpeg that we bundled earlier to:\ntake input from RTSP transport protocol argument flags for the video/audio codec Flag What it does -re read input at native frame rate. Mainly used to simulate a grab device i.e if you wanted to stream a video file, then you would want this, otherwise it might stream too fast -c:a aac transcode to AAC codec -ar 48000 set the audio sample rate -b:a 128k set the audio bitrate -c:v h264 or copy transcode to h264 codec or simply send the frame verbatim to output -hls_time the duration for video segment length -f flv says to deliver the output stream in an flv wrapper rtmp:// is where the transcoded video stream get pushed to The code is essentially a shell wrapper to FFmpeg command-line arguments. FFmpeg is the swiss-army tool for all video/audio codecs\nThe whole encoder.clj is about 300 lines long with error handling. It handles file uploads (video segment files, FFmpeg logs for debugging), egress to primary and secondary/fallback RTMP slot, shutdown processes, and the ec2 instance when we are done with the recording.\nLesson learned This was a rescue project from Go to Clojure. The previous architecture had too many moving pieces, making HTTP requests across multiple micro-services. The main server would crash daily due to improper handling of WebSocket messages, causing messages to be lost and encoder instances not starting up on time.\nThe rewrite reduced the complexities. Simple Made Easy as Rich Hickey.\nRewriting a project is never a good approach considering the opportunity cost. I evaluated a few offerings: mux.com, Cloudflare Stream, Amazon IVS. On paper, they have all the building blocks we need. In addition, some have features like video analytics, policing/signing playback URL, which would be useful for us.\nUltimately, the fact that we still had 2 years contract with the CDN company was why we still manage our encoder.\nIn hindsight, if we consider the storage costs and S3 egress bandwidth fee on top of the CDN costs, I would probably go for ready-made solutions for our company stage. I would start optimizing when we have more traffic.\nThe good thing is that this system works really well for live-streaming workload with programmatic access. (Sidenote: barring occasional internet hiccups in our studio).\nIf you have a video production pipeline that involves heavy video editing, going with prebuilt software could be more flexible until you solidify the core functionalities.\nSpecial thanks to: Daniel Fitzpatrick and Vincent Ho. My coworkers helped proofread this article and maintain the broadcast system. I enjoy working with you both ❤️. We even have automated tests to prove the camera stream is working end to end! Neil, our product manager, understands tech trade-offs and works with me to balance the product roadmap. Daniel Glauser, who hired me for this Clojure gig ","wordCount":"729","inLanguage":"en","datePublished":"2022-02-28T06:00:00Z","dateModified":"2022-02-28T06:00:00Z","author":{"@type":"Person","name":"David Liman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvliman.github.io/post/livestreaming-clojure/"},"publisher":{"@type":"Organization","name":"David Liman","logo":{"@type":"ImageObject","url":"https://dvliman.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvliman.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://dvliman.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvliman.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvliman.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvliman.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Live Streaming app in Clojure</h1><div class=post-meta><span title='2022-02-28 06:00:00 +0000 UTC'>February 28, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;729 words&nbsp;·&nbsp;David Liman&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/livestreaming-clojure.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I want to echo <a href=https://twitter.com/ID_AA_Carmack>John Carmack</a>’s <a href=https://twitter.com/ID_AA_Carmack/status/1258531455220609025>tweet that all giant companies use open-source FFmpeg in the backends</a>. <a href=https://www.ffmpeg.org/>FFmpeg</a> is a core piece of technology that powers our live-streaming and recording system at Inspire Fitness. It certainly is high-quality open-source software that we use to record and stream countless hours of workout videos.</p><p>It looks like this:<figure><img loading=lazy src=https://raw.githubusercontent.com/dvliman/dvliman.github.io/master/resources/public/images/live-sessions.png alt="live sessions" width=296 height=640></figure><figure><img loading=lazy src=https://raw.githubusercontent.com/dvliman/dvliman.github.io/master/resources/public/images/session-detail.png alt="session detail" width=296 height=640></figure></p><h1 id=users-can>Users can:<a hidden class=anchor aria-hidden=true href=#users-can>#</a></h1><ol><li>watch live-streaming content, or</li><li>playback on-demand videos from our content library</li></ol><h1 id=high-level>High level<a hidden class=anchor aria-hidden=true href=#high-level>#</a></h1><p>Behind the scene, we have:</p><ol><li>IP cameras are wired up in each studio room.</li><li>The cameras support the RTSP protocol.</li><li>A software pipeline integrated with our custom CMS to broadcast (stream) our cameras feed to the internet while simultaneously recording and storing the content to AWS S3 storage for on-demand playback.</li></ol><h1 id=how-it-all-works-together>How it all works together:<a hidden class=anchor aria-hidden=true href=#how-it-all-works-together>#</a></h1><ol><li><p>We configure classes (the recordings) to start at a particular time in our dashboard. The time aligns with our studio schedules, where gym members would often join our classes to work out alongside the instructors.</p></li><li><p>We <a href=https://docs.aws.amazon.com/cli/latest/reference/ec2/run-instances.html>kick off a dedicated ec2 instance with FFmpeg baked in an AMI image</a> when the class starts. We call this our encoder/transcoder.
<script src=https://gist.github.com/dvliman/2aa587f7b024615e4697da7b48a00120.js></script></p></li><li><p>As soon as the ec2 boots up, it runs the cloud-init script, which starts the Clojure process and <a href=https://github.com/tolitius/mount>mount</a> (a state management library) that would then starts the dependencies:
<script src=https://gist.github.com/dvliman/e4a63a35091e83ebae3d29d34ade450a.js></script></p></li><li><p>This would in turn calls <code>start-stream</code>:
<script src=https://gist.github.com/dvliman/607974927b33b0e734de3704976bb32f.js></script></p></li><li><p>The <code>start-stream</code> logic is actually pretty simple. It pulls feed from our camera and egress out our CDN partner
<script src=https://gist.github.com/dvliman/e604c2981bfb691803d84bd0b4858e39.js></script>The output would be a playback URL that our video player would be pulling from.</p></li></ol><p>Notice we are essentially invoking the FFmpeg that we bundled earlier to:</p><ol><li>take input from RTSP transport protocol</li><li><a href=https://www.ffmpeg.org/ffmpeg-formats.html>argument flags for the video/audio codec</a></li></ol><table><thead><tr><th>Flag</th><th>What it does</th></tr></thead><tbody><tr><td>-re</td><td>read input at native frame rate. Mainly used to simulate a grab device i.e if you wanted to stream a video file, then you would want this, otherwise it might stream too fast</td></tr><tr><td>-c:a aac</td><td>transcode to AAC codec</td></tr><tr><td>-ar 48000</td><td>set the audio sample rate</td></tr><tr><td>-b:a 128k</td><td>set the audio bitrate</td></tr><tr><td>-c:v h264 or copy</td><td>transcode to h264 codec or simply send the frame verbatim to output</td></tr><tr><td>-hls_time</td><td>the duration for video segment length</td></tr><tr><td>-f flv</td><td>says to deliver the output stream in an flv wrapper</td></tr><tr><td>rtmp://</td><td>is where the transcoded video stream get pushed to</td></tr></tbody></table><p>The code is essentially a shell wrapper to FFmpeg command-line arguments. FFmpeg is the swiss-army tool for all video/audio codecs</p><p>The whole <code>encoder.clj</code> is about 300 lines long with error handling. It handles file uploads (video segment files, FFmpeg logs for debugging), egress to primary and secondary/fallback RTMP slot, shutdown processes, and the ec2 instance when we are done with the recording.</p><h1 id=lesson-learned>Lesson learned<a hidden class=anchor aria-hidden=true href=#lesson-learned>#</a></h1><p>This was a rescue project from Go to Clojure. The previous architecture had too many moving pieces, making HTTP requests across multiple micro-services. The main server would crash daily due to improper handling of WebSocket messages, causing messages to be lost and encoder instances not starting up on time.</p><p>The rewrite reduced the complexities. <a href="https://www.youtube.com/watch?v=SxdOUGdseq4">Simple Made Easy</a> as <a href=https://clojure.org/about/history>Rich Hickey</a>.</p><p>Rewriting a project is never a good approach considering the opportunity cost. I evaluated a few offerings: <a href=http://mux.com>mux.com</a>, Cloudflare Stream, Amazon IVS. On paper, they have all the building blocks we need. In addition, some have features like video analytics, policing/signing playback URL, which would be useful for us.</p><p>Ultimately, the fact that we still had 2 years contract with the CDN company was why we still manage our encoder.</p><p>In hindsight, if we consider the storage costs and S3 egress bandwidth fee on top of the CDN costs, I would probably go for ready-made solutions for our company stage. I would start optimizing when we have more traffic.</p><p>The good thing is that this system works really well for live-streaming workload with programmatic access. (Sidenote: barring occasional internet hiccups in our studio).</p><p>If you have a video production pipeline that involves heavy video editing, going with prebuilt software could be more flexible until you solidify the core functionalities.</p><h1 id=special-thanks-to>Special thanks to:<a hidden class=anchor aria-hidden=true href=#special-thanks-to>#</a></h1><ol><li><a href=https://github.com/crinklywrappr>Daniel Fitzpatrick</a> and Vincent Ho. My coworkers helped proofread this article and maintain the broadcast system. I enjoy working with you both ❤️. We even have automated tests to prove the camera stream is working end to end!</li><li>Neil, our product manager, understands tech trade-offs and works with me to balance the product roadmap.</li><li>Daniel Glauser, who hired me for this Clojure gig</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://dvliman.github.io/post/dont-use-clj-time-use-clojurejava-time-instead/><span class=title>« Prev</span><br><span>Don't use clj-time, use clojure.java-time instead</span>
</a><a class=next href=https://dvliman.github.io/post/spring-webflux-kotlin-postgresql/><span class=title>Next »</span><br><span>Building a reactive web service with Spring Webflux, Kotlin, and PostgreSQL</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dvliman.github.io/>David Liman</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>